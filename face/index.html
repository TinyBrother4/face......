<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Face Mesh — Wireframe + Auto Pause (Fixed Resume)</title>

<style>
  html,body {
    height:100%;
    margin:0;
    background:#000;
    color:#0f0;
    font-family:monospace;
    overflow:hidden;
  }
  #video, #overlay {
    position:absolute;
    top:0; left:0;
    width:100%; height:100%;
    object-fit:cover;
  }
  #overlay { pointer-events:none; }

  #ui {
    position:absolute;
    top:8px; left:8px;
    background:rgba(0,0,0,0.65);
    padding:8px;
    border-radius:6px;
    z-index:10;
    font-size:13px;
  }

  button {
    background:#042;
    color:#0f0;
    border:1px solid #0f0;
    padding:6px 8px;
    border-radius:4px;
    cursor:pointer;
    margin-top:4px;
  }

  input[type=range] {
    width: 150px;
    margin-top:6px;
  }
</style>
</head>

<body>

<video id="video" autoplay playsinline muted></video>
<canvas id="overlay"></canvas>

<div id="ui">
  <div id="status">starting…</div>
  <button id="toggleMesh">Wireframe: OFF</button>
  <div style="margin-top:6px">
    Mesh Quality: <span id="meshQualityVal">Refined</span><br>
    <input type="range" id="meshQuality" min="0" max="1" step="1" value="1">
  </div>
</div>

<!-- MediaPipe (non-module) -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

<script>
(async function () {

  const statusEl = document.getElementById('status');
  const video = document.getElementById('video');
  const canvas = document.getElementById('overlay');
  const ctx = canvas.getContext('2d');

  const toggleBtn = document.getElementById('toggleMesh');
  const meshSlider = document.getElementById('meshQuality');
  const meshQualityVal = document.getElementById('meshQualityVal');

  let showWireframe = false;
  let refineLandmarks = meshSlider.value === '1';

  // Pause / resume state and debouncing counters
  let paused = false;
  let missingFrames = 0;
  let presentFrames = 0;
  const PAUSE_THRESHOLD = 12;   // number of consecutive frames without detection to pause
  const RESUME_THRESHOLD = 3;   // consecutive frames with detection to resume

  toggleBtn.onclick = () => {
    showWireframe = !showWireframe;
    toggleBtn.textContent = `Wireframe: ${showWireframe ? 'ON' : 'OFF'}`;
  };

  meshSlider.oninput = () => {
    refineLandmarks = meshSlider.value === '1';
    meshQualityVal.textContent = refineLandmarks ? 'Refined' : 'Basic';
    if (faceMesh) {
      // update options live
      faceMesh.setOptions({
        maxNumFaces: 2,
        refineLandmarks: refineLandmarks,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });
    }
  };

  function log(msg) {
    statusEl.textContent = msg;
    // also keep console logs for debugging
    console.log('[face]', msg);
  }

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  /* ---------------- Camera ---------------- */
  try {
    log('Requesting camera...');
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: 'user' }
    });
    video.srcObject = stream;
    await video.play();
    log('Camera ready');
  } catch (e) {
    console.error(e);
    log('Camera blocked — allow camera & reload');
    return;
  }

  /* ---------------- FaceMesh ---------------- */
  if (typeof FaceMesh === 'undefined') {
    log('FaceMesh not loaded (CDN blocked?)');
    return;
  }

  // create faceMesh variable in outer scope so slider can reference it
  let faceMesh = new FaceMesh({
    locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`
  });

  faceMesh.setOptions({
    maxNumFaces: 2,
    refineLandmarks: refineLandmarks,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
  });

  faceMesh.onResults(onResults);

  /* ---------------- Camera util: always send frames ----------------
     Previously we prevented sending frames when paused, which made resume impossible.
     Now we *always* send frames; onResults controls paused/resume logic.
  */
  const cameraUtil = new Camera(video, {
    onFrame: async () => {
      try {
        await faceMesh.send({ image: video });
      } catch (e) {
        // Non-fatal; log for debugging
        console.warn('faceMesh.send error', e);
      }
    },
    width: 1280,
    height: 720
  });

  cameraUtil.start();
  log('FaceMesh running — look at camera');

  /* ---------------- Drawing / Pause logic ---------------- */
  function onResults(results) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const gotFaces = !!(results && results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0);

    if (!gotFaces) {
      missingFrames++;
      presentFrames = 0;
      if (!paused && missingFrames >= PAUSE_THRESHOLD) {
        paused = true;
        log('No face detected — paused');
      } else {
        // show a softer message while waiting to pause
        log('No face detected...');
      }
      // still return early (nothing to draw)
      return;
    }

    // we have at least one face
    presentFrames++;
    missingFrames = 0;
    if (paused && presentFrames >= RESUME_THRESHOLD) {
      paused = false;
      log('Face detected — resumed');
    } else {
      // if not yet resumed, show tentative status
      if (paused) {
        log('Face seen — waiting to resume...');
        return;
      }
    }

    // If we reach here, not paused and have faces
    const vw = video.videoWidth;
    const vh = video.videoHeight;
    const sx = canvas.width / vw;
    const sy = canvas.height / vh;

    results.multiFaceLandmarks.forEach((landmarks, i) => {

      // Wireframe mesh
      if (showWireframe) {
        drawConnectors(ctx, landmarks, FACEMESH_TESSELATION, {
          color: 'rgba(0,255,255,0.35)',
          lineWidth: 1
        });
        drawConnectors(ctx, landmarks, FACEMESH_CONTOURS, {
          color: '#00ff00',
          lineWidth: 2
        });
      }

      // Bounding box
      let minX=1, minY=1, maxX=0, maxY=0;
      landmarks.forEach(p => {
        minX = Math.min(minX, p.x);
        minY = Math.min(minY, p.y);
        maxX = Math.max(maxX, p.x);
        maxY = Math.max(maxY, p.y);
      });

      ctx.strokeStyle = '#0f0';
      ctx.lineWidth = 3;
      ctx.strokeRect(
        minX * vw * sx,
        minY * vh * sy,
        (maxX - minX) * vw * sx,
        (maxY - minY) * vh * sy
      );

      // Landmark dots
      ctx.fillStyle = '#ff0';
      landmarks.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x * vw * sx, p.y * vh * sy, 1.6, 0, Math.PI * 2);
        ctx.fill();
      });

      log(`Face #${i+1}`);
    });
  }

})();
</script>
</body>
</html>
